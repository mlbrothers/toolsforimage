{% extends "fr/base.html" %}

{% block meta_description %}
<meta name="description" content="Recadrez vos images facilement avec ToolsForImage. Ajustez la zone de recadrage de manière interactive et visualisez les résultats en temps réel.">
{% endblock %}

{% block title %}Recadrer des Images en ligne | ToolsForImage | Outils en ligne gratuits et complets pour flouter les visages, convertir des images, éditer, redimensionner, supprimer l'arrière-plan, flouter l'arrière-plan et bien plus encore{% endblock %}

{% block content %}
<h1>Outil de Recadrage d'Images Gratuit</h1>
<p>Recadrez facilement votre image en sélectionnant la zone souhaitée. Visualisez vos modifications en temps réel.</p>

<form id="crop-form" method="post" enctype="multipart/form-data">
    <input type="file" id="image-upload" name="image" accept="image/*" style="display: none;" onchange="previewImage(event)">
    <button type="button" class="upload-button" onclick="document.getElementById('image-upload').click();">Télécharger l'Image</button>
    <br>
    <div class="image-preview-container">
        <img id="image-preview" src="#" alt="Aperçu de l'Image">
        <div id="crop-area">
            <div class="resize-handle nw"></div>
            <div class="resize-handle ne"></div>
            <div class="resize-handle sw"></div>
            <div class="resize-handle se"></div>
        </div>
    </div>
    <button type="button" class="crop-button" onclick="cropImage()">Recadrer l'Image</button>
</form>

<div class="info-container">
    <div class="info-section">
        <h2>Qu'est-ce que le Recadrage d'Image ?</h2>
        <p>Le recadrage d'image consiste à supprimer les zones extérieures indésirables d'une image pour améliorer sa composition. En mettant en valeur les éléments essentiels, le recadrage aide à créer une image attrayante qui transmet efficacement votre message. Que vous prépariez des photos pour un site web, les réseaux sociaux, ou un usage personnel, le recadrage est une étape cruciale de la retouche d'image qui peut améliorer considérablement la qualité globale.</p>
    </div>

    <div class="info-section">
        <h2>Avantages du Recadrage d'Images</h2>
        <p>Les images recadrées peuvent améliorer considérablement la narration visuelle. En éliminant les distractions, vous permettez à votre audience de se concentrer sur les parties les plus importantes de l'image. Ceci est particulièrement utile pour les photos de produits, où mettre en valeur l'objet de manière claire peut augmenter les ventes. De plus, le recadrage peut aider à obtenir des ratios spécifiques requis pour différentes plateformes, garantissant que vos images s'adaptent parfaitement aux sites web, blogs et réseaux sociaux.</p>
        <p>Par ailleurs, des images bien recadrées peuvent améliorer le temps de chargement de votre site web. Des images plus petites et optimisées améliorent l'expérience utilisateur et contribuent à de meilleurs classements SEO, les moteurs de recherche favorisant les pages à chargement rapide. Cela peut entraîner une augmentation du trafic et une visibilité accrue pour votre contenu.</p>
    </div>

    <div class="info-section">
        <h2>Quand Recadrer des Images</h2>
        <p>Pensez à recadrer vos images lorsque vous souhaitez améliorer la mise en valeur ou éliminer les éléments gênants. Cela est particulièrement important lors de la préparation d'images pour une utilisation en ligne, comme des articles de blog, des boutiques en ligne ou des profils de réseaux sociaux. Le recadrage peut également vous aider à créer des miniatures personnalisées qui attirent plus de clics, ce qui en fait un aspect essentiel du marketing digital.</p>
        <p>De plus, le recadrage est utile lorsque vous souhaitez créer une série d'images cohérentes pour un projet, comme un portfolio ou une présentation. En recadrant selon un ratio d'aspect cohérent, vous créez un aspect uniforme qui renforce le professionnalisme de votre travail.</p>
    </div>

    <div class="info-section">
        <h2>Conseils pour un Recadrage Efficace des Images</h2>
        <p>Voici quelques conseils à garder à l'esprit lors du recadrage d'images :</p>
        <ul>
            <li><strong>Utilisez la Règle des Tiers :</strong> Divisez votre image en une grille de neuf parties égales et placez les éléments clés le long de ces lignes ou à leurs intersections pour créer de l'équilibre et de l'intérêt.</li>
            <li><strong>Maintenez le Ratio d'Aspect :</strong> Tenez compte de la plateforme où l'image sera utilisée et recadrez en conséquence pour maintenir le ratio d'aspect souhaité. Cela garantit que vos images sont attrayantes partout.</li>
            <li><strong>Concentrez-vous sur le Sujet :</strong> Assurez-vous que le sujet principal est clairement visible et bien cadré. Évitez de laisser trop d'espace vide autour.</li>
            <li><strong>Expérimentez avec Différents Recadrages :</strong> N'hésitez pas à essayer plusieurs styles de recadrage pour voir ce qui convient le mieux à votre image et au message souhaité.</li>
        </ul>
    </div>

    <div class="info-section">
        <h2>Comment Recadrer des Images avec ToolsForImage</h2>
        <p>Chez ToolsForImage, recadrer vos images est simple et efficace. Notre interface conviviale vous permet de sélectionner la zone souhaitée pour le recadrage et d'en visualiser le résultat en temps réel. Téléchargez simplement votre image, ajustez la zone de recadrage selon vos besoins et téléchargez l'image recadrée en quelques clics. Que vous soyez un photographe professionnel ou un utilisateur occasionnel, notre outil de recadrage est conçu pour répondre à vos besoins avec précision et facilité.</p>
    </div>
</div>

<style>
    h1 {
        color: var(--secondary-color);
        font-family: var(--font-family);
        text-align: center;
    }

    main {
        padding: 2em;
        text-align: center;
    }

    .upload-button {
        background-color: var(--link-hover-color);
        color: var(--background-color);
        padding: 20px 40px;
        border: none;
        cursor: pointer;
        font-size: 20px;
        transition: transform 0.3s;
        border-radius: 5px; /* Added border radius */
    }

    .upload-button:hover {
        transform: scale(1.1);
    }

    .crop-button {
        background-color: var(--background-color);
        color: var(--box-hover-color);
        border: 2px solid var(--box-hover-color);
        padding: 10px 20px;
        cursor: pointer;
        font-size: 20px;
        transition: transform 0.3s;
        margin-top: 10px;
        border-radius: 5px; /* Added border radius */
    }

    .image-preview-container {
        position: relative;
        width: 100%;
        max-width: 800px;
        max-height: 600px;
        margin: 20px auto;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #image-preview {
        max-width: 100%;
        max-height: 100%;
        display: none;
        object-fit: contain;
    }

    #crop-area {
        position: absolute;
        border: 2px dashed #fff;
        cursor: move;
    }

    .resize-handle {
        width: 10px;
        height: 10px;
        background-color: white;
        position: absolute;
    }

    .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

    p {
        margin: 10px 20px;
        line-height: 1.6;
    }

    li {
        line-height: 1.6;
    }

    

    @media (max-width: 600px) {
        .image-preview-container {
            max-width: 100%;
            max-height: 400px;
        }
    }
</style>

<script>
    let cropArea, imagePreview, imagePreviewContainer;
    let isDragging = false;
    let isResizing = false;
    let startX, startY, startLeft, startTop, startWidth, startHeight;
    let currentHandle;
    let imageOffset = { x: 0, y: 0 };

    function validateImageSelection() {
        const imageUpload = document.getElementById('image-upload');
        if (!imageUpload.value) {
            alert('Please select an image to upload.');
            return false;
        }
        return true;
    }

    function previewImage(event) {
        imagePreview = document.getElementById('image-preview');
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                imagePreview.onload = function() {
                    initCropArea();
                }
            }
            reader.readAsDataURL(file);
        }
    }

    function initCropArea() {
        cropArea = document.getElementById('crop-area');
        imagePreviewContainer = document.querySelector('.image-preview-container');
        const containerRect = imagePreviewContainer.getBoundingClientRect();
        const imageRect = imagePreview.getBoundingClientRect();

        const scale = Math.min(containerRect.width / imageRect.width, containerRect.height / imageRect.height);
        const scaledWidth = imageRect.width * scale;
        const scaledHeight = imageRect.height * scale;

        // Calculate image offset
        imageOffset.x = (containerRect.width - scaledWidth) / 2;
        imageOffset.y = (containerRect.height - scaledHeight) / 2;

        // Adjust initial crop size for small images
        const initialCropSize = Math.min(scaledWidth, scaledHeight, 200);
        
        cropArea.style.width = `${initialCropSize}px`;
        cropArea.style.height = `${initialCropSize}px`;
        cropArea.style.left = `${imageOffset.x + (scaledWidth - initialCropSize) / 2}px`;
        cropArea.style.top = `${imageOffset.y + (scaledHeight - initialCropSize) / 2}px`;

        cropArea.addEventListener('mousedown', startDragging);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDragging);

        const resizeHandles = cropArea.querySelectorAll('.resize-handle');
        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', startResizing);
        });
    }

    function startDragging(e) {
        if (e.target.classList.contains('resize-handle')) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = cropArea.offsetLeft;
        startTop = cropArea.offsetTop;
        e.preventDefault();
    }

    function drag(e) {
        if (!isDragging) return;
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        let newLeft = startLeft + dx;
        let newTop = startTop + dy;
        
        // Constrain crop area within image bounds
        const imageRect = imagePreview.getBoundingClientRect();
        newLeft = Math.max(imageOffset.x, Math.min(newLeft, imageOffset.x + imageRect.width - cropArea.offsetWidth));
        newTop = Math.max(imageOffset.y, Math.min(newTop, imageOffset.y + imageRect.height - cropArea.offsetHeight));

        cropArea.style.left = newLeft + 'px';
        cropArea.style.top = newTop + 'px';
    }

    function stopDragging() {
        isDragging = false;
    }

    function startResizing(e) {
        isResizing = true;
        currentHandle = e.target;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(getComputedStyle(cropArea).width, 10);
        startHeight = parseInt(getComputedStyle(cropArea).height, 10);
        startLeft = cropArea.offsetLeft;
        startTop = cropArea.offsetTop;
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResizing);
        e.stopPropagation();
        e.preventDefault();
    }

    function resize(e) {
        if (!isResizing) return;
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        const imageRect = imagePreview.getBoundingClientRect();
        let newWidth, newHeight, newLeft, newTop;

        if (currentHandle.classList.contains('se')) {
            newWidth = Math.min(startWidth + dx, imageRect.width + imageOffset.x - startLeft);
            newHeight = Math.min(startHeight + dy, imageRect.height + imageOffset.y - startTop);
        } else if (currentHandle.classList.contains('sw')) {
            newWidth = Math.min(startWidth - dx, startLeft + startWidth - imageOffset.x);
            newHeight = Math.min(startHeight + dy, imageRect.height + imageOffset.y - startTop);
            newLeft = Math.max(imageOffset.x, startLeft + dx);
        } else if (currentHandle.classList.contains('ne')) {
            newWidth = Math.min(startWidth + dx, imageRect.width + imageOffset.x - startLeft);
            newHeight = Math.min(startHeight - dy, startTop + startHeight - imageOffset.y);
            newTop = Math.max(imageOffset.y, startTop + dy);
        } else if (currentHandle.classList.contains('nw')) {
            newWidth = Math.min(startWidth - dx, startLeft + startWidth - imageOffset.x);
            newHeight = Math.min(startHeight - dy, startTop + startHeight - imageOffset.y);
            newLeft = Math.max(imageOffset.x, startLeft + dx);
            newTop = Math.max(imageOffset.y, startTop + dy);
        }

        // Ensure minimum size for crop area
        const minSize = 20;
        newWidth = Math.max(newWidth, minSize);
        newHeight = Math.max(newHeight, minSize);

        cropArea.style.width = `${newWidth}px`;
        cropArea.style.height = `${newHeight}px`;
        if (newLeft !== undefined) cropArea.style.left = `${newLeft}px`;
        if (newTop !== undefined) cropArea.style.top = `${newTop}px`;
    }

    function stopResizing() {
        isResizing = false;
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResizing);
    }

    function cropImage() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const imageRect = imagePreview.getBoundingClientRect();
        const cropRect = cropArea.getBoundingClientRect();

        const scaleX = imagePreview.naturalWidth / imageRect.width;
        const scaleY = imagePreview.naturalHeight / imageRect.height;

        const cropX = (cropRect.left - imageRect.left) * scaleX;
        const cropY = (cropRect.top - imageRect.top) * scaleY;
        const cropWidth = cropRect.width * scaleX;
        const cropHeight = cropRect.height * scaleY;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
            imagePreview,
            cropX, cropY, cropWidth, cropHeight,
            0, 0, cropWidth, cropHeight
        );

        // Convert canvas to image and download
        canvas.toBlob((blob) => {
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = 'cropped_image.png';
            downloadLink.click();
        }, 'image/png');
    }
</script>
{% endblock %}
